## Subtopic 1.6: Practice: Common Coding Interview Problems

**Goal:** To solidify understanding and improve problem-solving speed for common coding interview question patterns by applying the data structures, algorithms, and Python techniques learned in subtopics 1.1-1.3.

**Resources:**

  * Practice Platforms: [LeetCode](https://leetcode.com/), [HackerRank](https://www.hackerrank.com/), [Codewars](https://www.codewars.com/)
  * Problem Pattern Guides: [LeetCode Explore Cards](https://leetcode.com/explore/), [NeetCode.io (Roadmap & Explanations)](https://neetcode.io/)
  * Book: "Cracking the Coding Interview" by Gayle Laakmann McDowell (Chapters on Arrays & Strings, Linked Lists, Trees & Graphs, Recursion & Dynamic Programming)
  * Your notes and implementations from Subtopics 1.1, 1.2, 1.3.

-----

### Exercise 1: Array/String Manipulation Practice

**Goal:** Solve common interview problems involving array and string manipulation.
**Instructions:**

1.  Go to a practice platform like LeetCode.
2.  Find and solve at least 3 "Easy" or "Medium" problems tagged with "Array" or "String". Examples include:
      * "Two Sum" (Hash Map usage)
      * "Valid Parentheses" (Stack usage)
      * "Best Time to Buy and Sell Stock" (Simple iteration/tracking min)
      * "Reverse String" (In-place manipulation or slicing)
      * "Valid Palindrome" (Two Pointers)
3.  Focus on writing clean, efficient code.
4.  Analyze the time and space complexity of your solutions. Try to achieve the optimal complexity.

### Exercise 2: Linked List Problem Practice

**Goal:** Solve common interview problems involving linked list manipulation.
**Instructions:**

1.  Go to a practice platform like LeetCode.
2.  Find and solve at least 2-3 "Easy" or "Medium" problems tagged with "Linked List". Examples include:
      * "Reverse Linked List" (Iterative or Recursive)
      * "Merge Two Sorted Lists"
      * "Linked List Cycle" (Floyd's Tortoise and Hare algorithm)
      * "Remove Nth Node From End of List" (Two Pointers)
3.  Use the `Node` class structure if implementing from scratch, or adapt to the platform's provided structure.
4.  Pay attention to edge cases (empty list, single node list, etc.).

### Exercise 3: Tree Traversal & Problem Practice

**Goal:** Solve common interview problems involving binary tree traversals and properties.
**Instructions:**

1.  Go to a practice platform like LeetCode.
2.  Find and solve at least 2-3 "Easy" or "Medium" problems tagged with "Tree". Examples include:
      * "Maximum Depth of Binary Tree" (Recursive DFS)
      * "Invert Binary Tree" (Recursive)
      * "Same Tree" (Recursive comparison)
      * "Binary Tree Inorder Traversal" (Implement iteratively using a stack)
      * "Validate Binary Search Tree" (Recursive with range constraints)
3.  Utilize the traversal patterns (In-order, Pre-order, Post-order, Level-order/BFS) as appropriate.

### Exercise 4: Hash Map / Dictionary Application Practice

**Goal:** Solve problems where hash maps provide efficient solutions for lookups, frequency counting, or grouping.
**Instructions:**

1.  Go to a practice platform like LeetCode.
2.  Find and solve at least 2-3 "Easy" or "Medium" problems where hash maps (`dict` or `collections.Counter`/`defaultdict`) are key. Examples include:
      * "Contains Duplicate"
      * "Group Anagrams"
      * "Valid Anagram"
      * "Top K Frequent Elements" (Use hash map + heap/sorting)
3.  Focus on leveraging the O(1) average time complexity for insertions and lookups in hash maps.

### Exercise 5: Recursion / Backtracking Introduction Practice

**Goal:** Solve introductory problems that can be effectively approached using recursion or backtracking.
**Instructions:**

1.  Go to a practice platform like LeetCode.
2.  Find and solve at least 1-2 "Easy" or "Medium" problems suitable for recursion/backtracking. Examples include:
      * "Generate Parentheses" (Backtracking)
      * "Subsets" (Backtracking/Recursive)
      * Problems involving permutations or combinations (can leverage `itertools` or implement recursively).
3.  Focus on defining the base case(s) and recursive step(s) clearly.
4.  Understand how the call stack manages recursive calls.
